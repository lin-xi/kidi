(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{368:function(t,e,s){"use strict";s.r(e);var a=s(42),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"请求-request"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#请求-request"}},[t._v("#")]),t._v(" 请求(Request)")]),t._v(" "),s("p",[t._v("Koa Request 对象是在 node 的 原生请求对象之上的抽象，提供了诸多对 HTTP 服务器开发有用的功能。")]),t._v(" "),s("h2",{attrs:{id:"api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#api"}},[t._v("#")]),t._v(" API")]),t._v(" "),s("p",[s("strong",[t._v("request.header")]),t._v("\n请求头对象。这与 node http.IncomingMessage 上的 headers 字段相同")]),t._v(" "),s("p",[s("strong",[t._v("request.header=")]),t._v("\n设置请求头对象。")]),t._v(" "),s("p",[s("strong",[t._v("request.headers")]),t._v("\n请求头对象。别名为 request.header.")]),t._v(" "),s("p",[s("strong",[t._v("request.headers=")]),t._v("\n设置请求头对象。别名为 request.header=.")]),t._v(" "),s("p",[s("strong",[t._v("request.method")]),t._v("\n请求方法。")]),t._v(" "),s("p",[s("strong",[t._v("request.method=")]),t._v("\n设置请求方法，对于实现诸如 methodOverride() 的中间件是有用的。")]),t._v(" "),s("p",[s("strong",[t._v("request.length")]),t._v("\n返回以数字返回请求的 Content-Length，或 undefined。")]),t._v(" "),s("p",[s("strong",[t._v("request.url")]),t._v("\n获取请求 URL.")]),t._v(" "),s("p",[s("strong",[t._v("request.url=")]),t._v("\n设置请求 URL, 对 url 重写有用。")]),t._v(" "),s("p",[s("strong",[t._v("request.originalUrl")]),t._v("\n获取请求原始 URL。")]),t._v(" "),s("p",[s("strong",[t._v("request.origin")]),t._v("\n获取 URL 的来源，包括 protocol 和 host。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("ctx.request.origin\n// => http://example.com\n")])])]),s("p",[s("strong",[t._v("request.href")]),t._v("\n获取完整的请求 URL，包括 protocol，host 和 url。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("ctx.request.href;\n// => http://example.com/foo/bar?q=1\n")])])]),s("p",[s("strong",[t._v("request.path")]),t._v("\n获取请求路径名。")]),t._v(" "),s("p",[s("strong",[t._v("request.path=")]),t._v("\n设置请求路径名，并在存在时保留查询字符串。")]),t._v(" "),s("p",[s("strong",[t._v("request.querystring")]),t._v("\n根据 ? 获取原始查询字符串.")]),t._v(" "),s("p",[s("strong",[t._v("request.querystring=")]),t._v("\n设置原始查询字符串。")]),t._v(" "),s("p",[s("strong",[t._v("request.search")]),t._v("\n使用 ? 获取原始查询字符串。")]),t._v(" "),s("p",[s("strong",[t._v("request.search=")]),t._v("\n设置原始查询字符串。")]),t._v(" "),s("p",[s("strong",[t._v("request.host")]),t._v("\n存在时获取主机（hostname:port）。当 app.proxy 是 true 时支持 X-Forwarded-Host，否则使用 Host。")]),t._v(" "),s("p",[s("strong",[t._v("request.hostname")]),t._v("\n存在时获取主机名。当 app.proxy 是 true 时支持 X-Forwarded-Host，否则使用 Host。")]),t._v(" "),s("p",[t._v("如果主机是 IPv6, Koa 解析到 WHATWG URL API, 注意 这可能会影响性能。")]),t._v(" "),s("p",[s("strong",[t._v("request.URL")]),t._v("\n获取 WHATWG 解析的 URL 对象。")]),t._v(" "),s("p",[s("strong",[t._v("request.type")]),t._v('\n获取请求 Content-Type, 不含 "charset" 等参数。')]),t._v(" "),s("p",[t._v("译者注: 这里其实是只获取 mime-type, 详见源码及其注释")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('const ct = ctx.request.type;\n// => "image/png"\n')])])]),s("p",[s("strong",[t._v("request.charset")]),t._v("\n存在时获取请求字符集，或者 undefined：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('ctx.request.charset;\n// => "utf-8"\n')])])]),s("p",[s("strong",[t._v("request.query")]),t._v("\n获取解析的查询字符串, 当没有查询字符串时，返回一个空对象。请注意，此 getter "),s("em",[t._v("不")]),t._v(" 支持嵌套解析。")]),t._v(" "),s("p",[t._v('例如 "color=blue&size=small":')]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("{\n    color: 'blue',\n    size: 'small'\n}\n")])])]),s("p",[s("strong",[t._v("request.query=")]),t._v("\n将查询字符串设置为给定对象。 请注意，此 setter "),s("em",[t._v("不")]),t._v(" 支持嵌套对象。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("ctx.query = { next: '/login' };\n")])])]),s("p",[s("strong",[t._v("request.fresh")]),t._v("\n检查请求缓存是否“新鲜”，也就是内容没有改变。此方法用于 If-None-Match / ETag, 和 If-Modified-Since 和 Last-Modified 之间的缓存协商。 在设置一个或多个这些响应头后应该引用它。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// 新鲜度检查需要状态 20x 或 304\nctx.status = 200;\nctx.set('ETag', '123');\n\n// 缓存是好的\nif (ctx.fresh) {\nctx.status = 304;\nreturn;\n}\n\n// 缓存是陈旧的\n// 获取新数据\nctx.body = await db.find('something');\n")])])]),s("p",[s("strong",[t._v("request.stale")]),t._v("\n与 request.fresh 相反.")]),t._v(" "),s("p",[s("strong",[t._v("request.protocol")]),t._v("\n返回请求协议，“https” 或 “http”。当 app.proxy 是 true 时支持 X-Forwarded-Proto。")]),t._v(" "),s("p",[s("strong",[t._v("request.secure")]),t._v('\n通过 ctx.protocol == "https" 来检查请求是否通过 TLS 发出。')]),t._v(" "),s("p",[s("strong",[t._v("request.ip")]),t._v("\n请求远程地址。 当 app.proxy 是 true 时支持 X-Forwarded-Proto。")]),t._v(" "),s("p",[s("strong",[t._v("request.ips")]),t._v("\n当 X-Forwarded-For 存在并且 app.proxy 被启用时，这些 ips 的数组被返回，从上游 - >下游排序。 禁用时返回一个空数组。")]),t._v(" "),s("p",[t._v('例如，如果值是 "client, proxy1, proxy2"，将会得到数组 ["client", "proxy1", "proxy2"]。')]),t._v(" "),s("p",[t._v("大多数反向代理（nginx）都通过 proxy_add_x_forwarded_for 设置了 x-forwarded-for，这带来了一定的安全风险。恶意攻击者可以通过伪造 X-Forwarded-For 请求头来伪造客户端的 ip 地址。 客户端发送的请求具有 'forged' 的 X-Forwarded-For 请求头。 在由反向代理转发之后，request.ips 将是 ['forged', 'client', 'proxy1', 'proxy2']。")]),t._v(" "),s("p",[t._v("Koa 提供了两种方式来避免被绕过。")]),t._v(" "),s("p",[t._v("如果您可以控制反向代理，则可以通过调整配置来避免绕过，或者使用 koa 提供的 app.proxyIpHeader 来避免读取 x-forwarded-for 获取 ips。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("const app = new Koa({\n    proxy: true,\n    proxyIpHeader: 'X-Real-IP',\n});\n")])])]),s("p",[t._v("如果您确切知道服务器前面有多少个反向代理，则可以通过配置 app.maxIpsCount 来避免读取用户的伪造的请求头：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("const app = new Koa({\n    proxy: true,\n    maxIpsCount: 1, // 服务器前只有一个代理\n});\n\n// request.header['X-Forwarded-For'] === [ '127.0.0.1', '127.0.0.2' ];\n// ctx.ips === [ '127.0.0.2' ];\n")])])]),s("p",[s("strong",[t._v("request.subdomains")]),t._v("\n以数组形式返回子域。")]),t._v(" "),s("p",[t._v("子域是应用程序主域之前主机的点分隔部分。默认情况下，应用程序的域名假定为主机的最后两个部分。这可以通过设置 app.subdomainOffset 来更改。")]),t._v(" "),s("p",[t._v("例如，如果域名为“tobi.ferrets.example.com”：")]),t._v(" "),s("p",[t._v('如果 app.subdomainOffset 未设置, ctx.subdomains 是 ["ferrets", "tobi"]. 如果 app.subdomainOffset 是 3, ctx.subdomains 是 ["tobi"].')]),t._v(" "),s("p",[t._v("request.is(types...)\n检查传入请求是否包含 Content-Type 消息头字段， 并且包含任意的 mime type。 如果没有请求主体，返回 null。 如果没有内容类型，或者匹配失败，则返回 false。 反之则返回匹配的 content-type。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// 使用 Content-Type: text/html; charset=utf-8\nctx.is('html'); // => 'html'\nctx.is('text/html'); // => 'text/html'\nctx.is('text/\\*', 'text/html'); // => 'text/html'\n\n// 当 Content-Type 是 application/json 时\nctx.is('json', 'urlencoded'); // => 'json'\nctx.is('application/json'); // => 'application/json'\nctx.is('html', 'application/\\*'); // => 'application/json'\n\nctx.is('html'); // => false\n")])])]),s("p",[t._v("例如，如果要确保仅将图像发送到给定路由：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("if (ctx.is('image/\\*')) {\n    // 处理\n} else {\n    ctx.throw(415, 'images only!');\n}\n")])])]),s("h2",{attrs:{id:"内容协商"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内容协商"}},[t._v("#")]),t._v(" 内容协商")]),t._v(" "),s("p",[t._v("Koa 的 request 对象包括由 accepts 和 negotiator 提供的内容协商实用函数。")]),t._v(" "),s("p",[t._v("这些实用函数是：")]),t._v(" "),s("p",[t._v("request.accepts(types)")]),t._v(" "),s("p",[t._v("request.acceptsEncodings(types)")]),t._v(" "),s("p",[t._v("request.acceptsCharsets(charsets)")]),t._v(" "),s("p",[t._v("request.acceptsLanguages(langs)")]),t._v(" "),s("p",[t._v("如果没有提供类型，则返回 所有 可接受的类型。")]),t._v(" "),s("p",[t._v('如果提供多种类型，将返回最佳匹配。 如果没有找到匹配项，则返回一个 false，你应该向客户端发送一个 406 "Not Acceptable" 响应。')]),t._v(" "),s("p",[t._v("如果接收到任何类型的接收头，则会返回第一个类型。 因此，你提供的类型的顺序很重要。")]),t._v(" "),s("p",[s("strong",[t._v("request.accepts(types)")])]),t._v(" "),s("p",[t._v('检查给定的 type(s) 是否可以接受，如果 true，返回最佳匹配，否则为 false。 type 值可能是一个或多个 mime 类型的字符串，如 application/json，扩展名称如 json，或数组 ["json", "html", "text/plain"]。')]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// Accept: text/html\nctx.accepts('html');\n// => \"html\"\n\n// Accept: text/\\*, application/json\nctx.accepts('html');\n// => \"html\"\nctx.accepts('text/html');\n// => \"text/html\"\nctx.accepts('json', 'text');\n// => \"json\"\nctx.accepts('application/json');\n// => \"application/json\"\n\n// Accept: text/\\*, application/json\nctx.accepts('image/png');\nctx.accepts('png');\n// => false\n\n// Accept: text/\\*;q=.5, application/json\nctx.accepts(['html', 'json']);\nctx.accepts('html', 'json');\n// => \"json\"\n\n// No Accept header\nctx.accepts('html', 'json');\n// => \"html\"\nctx.accepts('json', 'html');\n// => \"json\"\n")])])]),s("p",[t._v("你可以根据需要多次调用 ctx.accepts()，或使用 switch：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("switch (ctx.accepts('json', 'html', 'text')) {\n    case 'json': break;\n    case 'html': break;\n    case 'text': break;\n    default: ctx.throw(406, 'json, html, or text only');\n}\n")])])]),s("p",[s("strong",[t._v("request.acceptsEncodings(encodings)")])]),t._v(" "),s("p",[t._v("检查 encodings 是否可以接受，返回最佳匹配为 true，否则为 false。 请注意，您应该将 identity 作为编码之一！")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// Accept-Encoding: gzip\nctx.acceptsEncodings('gzip', 'deflate', 'identity');\n// => \"gzip\"\n\nctx.acceptsEncodings(['gzip', 'deflate', 'identity']);\n// => \"gzip\"\n当没有给出参数时，所有接受的编码将作为数组返回：\n\n// Accept-Encoding: gzip, deflate\nctx.acceptsEncodings();\n// => [\"gzip\", \"deflate\", \"identity\"]\n")])])]),s("p",[t._v("请注意，如果客户端显式地发送 identity;q=0，那么 identity 编码（这意味着没有编码）可能是不可接受的。 虽然这是一个边缘的情况，你仍然应该处理这种方法返回 false 的情况。")]),t._v(" "),s("p",[s("strong",[t._v("request.acceptsCharsets(charsets)")])]),t._v(" "),s("p",[t._v("检查 charsets 是否可以接受，在 true 时返回最佳匹配，否则为 false。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5\nctx.acceptsCharsets('utf-8', 'utf-7');\n// => \"utf-8\"\n\nctx.acceptsCharsets(['utf-7', 'utf-8']);\n// => \"utf-8\"\n")])])]),s("p",[t._v("当没有参数被赋予所有被接受的字符集将作为数组返回：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('// Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5\nctx.acceptsCharsets();\n// => ["utf-8", "utf-7", "iso-8859-1"]\n')])])]),s("p",[s("strong",[t._v("request.acceptsLanguages(langs)")])]),t._v(" "),s("p",[t._v("检查 langs 是否可以接受，如果为 true，返回最佳匹配，否则为 false。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// Accept-Language: en;q=0.8, es, pt\nctx.acceptsLanguages('es', 'en');\n// => \"es\"\n\nctx.acceptsLanguages(['en', 'es']);\n// => \"es\"\n")])])]),s("p",[t._v("当没有参数被赋予所有接受的语言将作为数组返回：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('// Accept-Language: en;q=0.8, es, pt\nctx.acceptsLanguages();\n// => ["es", "pt", "en"]\n')])])]),s("p",[s("strong",[t._v("request.idempotent")])]),t._v(" "),s("p",[t._v("检查请求是否是幂等的。")]),t._v(" "),s("p",[s("strong",[t._v("request.socket")])]),t._v(" "),s("p",[t._v("返回请求套接字。")]),t._v(" "),s("p",[s("strong",[t._v("request.get(field)")])]),t._v(" "),s("p",[t._v("返回请求头(header), field 不区分大小写.")])])}),[],!1,null,null,null);e.default=n.exports}}]);